/**
 * @file Tools for working with Option type
 * Option is modeled as type of `T | undefined`.
 */

/** A type of value, null, or undefined */
export type Nullish<T> = T | null | undefined;

/** A type of value or undefined */
export type Option<T> = T | undefined;

/**
 * Create an option from a nullish value.
 * Coalesces null to undefined.
 */
export const from = <T>(value: Nullish<T>): Option<T> => value ?? undefined;

/** Is value something that is not undefined? */
export const isSome = <T>(value: Option<T>): value is T => value !== undefined;

/** Is value undefined? */
export const isNone = (value: unknown): value is undefined =>
  value === undefined;

/** Is value nullish? */
export const isNullish = (value: unknown): value is null | undefined =>
  value === null || value === undefined;

/** Unwrap optional value, throwing a TypeError if none. */
export const unwrap = <T>(value: Option<T>): T => {
  if (isNone(value)) {
    throw new TypeError("Value is undefined");
  }
  return value;
};

/** Unwrap optional value, or fall back to default value. */
export const unwrapOr = <T>(value: Option<T>, defaultValue: T): T =>
  isSome(value) ? value : defaultValue;

/** Unwrap value or fall back to a default generated by a function */
export const unwrapOrElse = <T>(value: Option<T>, fn: () => T): T =>
  isSome(value) ? value : fn();

/** Map optional value. Mapping function is only called if value is not none. */
export const map = <T, U>(
  value: Option<T>,
  fn: (value: T) => Option<U>,
): Option<U> => (isSome(value) ? fn(value) : undefined);

/** Map or fall back to default value */
export const mapOr = <T, U>(
  value: Option<T>,
  defaultValue: U,
  fn: (value: T) => U,
): Option<U> => (isSome(value) ? fn(value) : defaultValue);

/** Map or fall back to default value generated by a function */
export const mapOrElse = <T, U>(
  value: Option<T>,
  fn: () => U,
  defaultValue: U,
): Option<U> => (isSome(value) ? fn() : defaultValue);
