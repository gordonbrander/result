/**
 * @file Data-last curried combinators for Option
 *
 * Each combinator takes its function/value arguments first and returns
 * a function that accepts an Option â€” ideal for composition and piping.
 */

import * as Opt from "../option.ts";
import type { Option } from "../option.ts";

/** Unwrap Option, or fall back to a default value if None. */
export const unwrapOr = <T>(defaultValue: T) => (value: Option<T>): T =>
  Opt.unwrapOr(value, defaultValue);

/** Unwrap Option, or compute a fallback if None. */
export const unwrapOrElse = <T>(fn: () => T) => (value: Option<T>): T =>
  Opt.unwrapOrElse(value, fn);

/** Map Option value. Mapping function is only called if value is Some. */
export const map =
  <T, U>(fn: (value: T) => Option<U>) => (value: Option<T>): Option<U> =>
    Opt.map(value, fn);

/** Map or fall back to default value. */
export const mapOr =
  <T, U>(defaultValue: U, fn: (value: T) => U) =>
  (value: Option<T>): Option<U> => Opt.mapOr(value, defaultValue, fn);

/** Map or fall back to default value generated by a function. */
export const mapOrElse =
  <T, U>(fn: () => U, defaultValue: U) => (value: Option<T>): Option<U> =>
    Opt.mapOrElse(value, fn, defaultValue);
